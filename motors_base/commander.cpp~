#include<ros/ros.h>
#include<std_msgs/Float64.h>
#include<stdio.h>
#include<dynamixel_msgs/JointState.h>

using namespace std;

float error;
int go = 0;
float place;

//obtains error from message
void obtainValues(const dynamixel_msgs::JointState &msg)
{
  error = msg.error;
}  

//creates all commands for each motor
class Dynamixel
{
  private:
  ros::NodeHandle nh;
  ros::Publisher pub_n;
  public:
  Dynamixel();
  void checkError();
  void moveMotor(double position);
};

//creates publisher
Dynamixel::Dynamixel()
{
  pub_n = nh.advertise<std_msgs::Float64>("/tilt_controller/command", 1);
}

//creates message and publishes -> degree to radian to publish
 void Dynamixel::moveMotor(double position)
{
  double convert = (position * 3.14/180);
  std_msgs::Float64 aux;
  aux.data = convert;
  pub_n.publish(aux);
  ROS_INFO_STREAM(aux);
}

//ensures proper alignment
void Dynamixel::checkError()
{
  while(error>0.002)
  {
    ros::Duration(0.01).sleep();
    ros::Subscriber sub=nh.subscribe("/tilt_controller/state", 5, &obtainValues); //checks error
  }
}


//obtains requested position
void transfer(const std_msgs::Float64 &msg)
{
   place = msg.data;
   go = 1;
}

//main
int main (int argc, char **argv)
{
  //initializes
  ros::init(argc, argv, "commander");
  ros::NodeHandle nh;
  
  //creates 1 Dynamixel named motor
  Dynamixel motor;

  //subscribes to external requests
  ros::Subscriber sub_2=nh.subscribe("/commands", 1, &transfer);  //external

//weird ross::ok() and spinOnce() loop needed to make it work
while(ros::ok())
 {
  //if new request has been received
  if(go==1)
  {
    //move motor to request
    motor.moveMotor(place);
    motor.checkError();
    ros::Duration(0.5).sleep(); //saftety break
    go = 0;
  }
  
  else
  { 
    ros::spinOnce();
  }
 }
}
